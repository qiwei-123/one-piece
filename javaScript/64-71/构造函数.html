<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>构造函数</title>
</head>

<body>

</body>
<script>
    /*    - 构造函数 -
        创建一个构造函数，专门用来创建Person对象的
        构造函数就是一个普通的函数，创建方式和普通函数没有区别
        不同的是构造函数习惯上首字母大写

        构造函数和普通函数的区别就是调用方式的不同
        普通函数是直接调用，而构造函数需要使用new关键字来调用

        构造函数的执行流程
        1.立刻创建一个新的对象
        2.将新建的对象设置为函数中的this，在构造函数中可以使用this来引用新建的对象
        3.逐行执行函数中代码
        4.将新建的对象作为返回值返回

        this的情况 ： 
        1.当以函数的形式调用时，this是window
        2.当以方法的形式调用时，谁调用方法this就是谁
        3.当以构造函数的形式调用时，this就是新创建的那个对象
          - 原型 prototype-
        创建的每一个函数，解析器都会向函数中添加一个属性prototype
        这个属性对应着一个对象，这个对象就是所谓的原型对象
        如果函数作为普通函数调用prototype没有任何作用
        当函数以构造函数的形式调用时，他所创建的对象中都会有一个隐含的属性
            指向该构造函数的原型对象，我们可以通过__proto__来访问该属性

        原型对象就相当于一个公共的区域，所有同一类的实例都可以访问到这个原型对象
            可以将对象中共有的内容，统一设置到原型对象中
        当访问对象的一个属性或方法时，他会先在对象自身中寻找，如果有则直接用，
            如果没有则会去原型对象中寻找
        创建构造函数时，可以将这些对象共有的属性和方法，统一添加到构造函数的原型对象中
    */
    function Person(name, age, gender) {
        this.name = name;
        this.age = age;
        this.gender = gender;
    }
    // 向Person的原型中添加一个属性a
    Person.prototype.a =123;
    // 向Person的原型中添加一个方法
    Person.prototype.sayName = function () {
        console.log();
    }
    var per = new Person("艾希", 19, "woman");
    console.log(per);


    // function Person(name, age, gender) {
    //     this.name = name;
    //     this.age = age;
    //     this.gender = gender;
    //     this.sayName = function () {
    //         console.log(this.name);
    //     };
    // }
    // /* 输入想打印出的信息 */
    // var per = new Person("艾希", 19, "woman");
    // var per2 = new Person("瑞兹", 38, "man");
    // var per3 = new Person("卡莎", 24, "woman");
    // var per4 = new Person("德玛西亚皇子", 42, "man");
    // var per5 = new Person("泰达米尔", 39, "man");
    // /* 打印出想要的信息 */
    // function Animal(name, age, gender) {
    //     this.name = name;
    //     this.age = age;
    //     this.gender = gender;
    //     this.sayName = function () {
    //         console.log(this.name);
    //     };
    // }
    // var ani = new Animal("提莫", 39, "unknow");
    // /* 构造函数之后，打印出来的对象可以指定为 person或animal等，按照自己所想创建对象名 */
    // console.log(per);
    // console.log(per2);
    // console.log(per3);
    // console.log(per4);
    // console.log(per5);
    // console.log(ani);
    // /* 
    //     使用 instanceof 可以检查一个对象是否是一个类的实例 
    //     若是 ：true  否： false
    //     所有的对象都是Object的后代
    // */
    // console.log(per instanceof Animal);
    // console.log(ani instanceof Object);
    // // 创建一个构造函数
    // // 在Test构造函数中，为每一个对象都添加了一个sayName方法，
    // // 目前我们的方法是在构造函数内部创建的，也就是构造函数每执行一次就会创建一个新的sayName方法
    // // 也就是所有实例的sayName都是唯一的
    // // 这样就导致了构造函数执行一次创建一个新的方法
    // // 执行1w次会有1w个新的方法，而这些方法是一模一样的，完全没必要
    // function Test(name, age, gender) {
    //     this.name = name;
    //     this.age = age;
    //     this.gender = gender;
    //     // 向对象中添加一个方法
    //     this.sayName = fun;
    // }

</script>

</html>